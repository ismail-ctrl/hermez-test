"use strict";

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.array.join.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._getPageData = _getPageData;
exports.setBaseApiUrl = setBaseApiUrl;
exports.getBaseApiUrl = getBaseApiUrl;
exports.getAccounts = getAccounts;
exports.getAccount = getAccount;
exports.getTransactions = getTransactions;
exports.getHistoryTransaction = getHistoryTransaction;
exports.getPoolTransaction = getPoolTransaction;
exports.postPoolTransaction = postPoolTransaction;
exports.getExit = getExit;
exports.getExits = getExits;
exports.getTokens = getTokens;
exports.getToken = getToken;
exports.getState = getState;
exports.getBatches = getBatches;
exports.getBatch = getBatch;
exports.getCoordinators = getCoordinators;
exports.getSlot = getSlot;
exports.getBids = getBids;
exports.postCreateAccountAuthorization = postCreateAccountAuthorization;
exports.PaginationOrder = void 0;

require("regenerator-runtime/runtime.js");

var _axios = _interopRequireDefault(require("axios"));

var _http = require("./http.js");

var _constants = require("./constants.js");

var _addresses = require("./addresses.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var PaginationOrder = {
  ASC: 'ASC',
  DESC: 'DESC'
};
/**
 * Sets the query parameters related to pagination
 * @param {Number} fromItem - Item from where to start the request
 * @returns {Object} Includes the values `fromItem` and `limit`
 * @private
 */

exports.PaginationOrder = PaginationOrder;

function _getPageData(fromItem, order, limit) {
  return _objectSpread(_objectSpread({}, fromItem !== undefined ? {
    fromItem: fromItem
  } : {}), {}, {
    order: order,
    limit: limit
  });
}

var baseApiUrl = _constants.BASE_API_URL;
/**
 * Sets the current coordinator API URL
 * @param {String} url - The currently forging Coordinator
 */

function setBaseApiUrl(url) {
  baseApiUrl = url;
}
/**
 * Returns current coordinator API URL
 * @returns {String} The currently set Coordinator
*/


function getBaseApiUrl() {
  return baseApiUrl;
}
/**
 * GET request to the /accounts endpoint. Returns a list of token accountns associated to a Hermez address
 * @param {String} address - The account's address. It can be a Hermez Ethereum address or a Hermez BabyJubJub address
 * @param {Number[]} tokenIds - Array of token IDs as registered in the network
 * @param {Number} fromItem - Item from where to start the request
 * @returns {Object} Response data with filtered token accounts and pagination data
 */


function getAccounts(_x, _x2, _x3) {
  return _getAccounts.apply(this, arguments);
}
/**
 * GET request to the /accounts/:accountIndex endpoint. Returns a specific token account for an accountIndex
 * @param {String} accountIndex - Account index in the format hez:DAI:4444
 * @returns {Object} Response data with the token account
 */


function _getAccounts() {
  _getAccounts = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(address, tokenIds, fromItem) {
    var order,
        limit,
        params,
        _args = arguments;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            order = _args.length > 3 && _args[3] !== undefined ? _args[3] : PaginationOrder.ASC;
            limit = _args.length > 4 && _args[4] !== undefined ? _args[4] : _constants.DEFAULT_PAGE_SIZE;
            params = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, (0, _addresses.isHermezEthereumAddress)(address) ? {
              hezEthereumAddress: address
            } : {}), (0, _addresses.isHermezBjjAddress)(address) ? {
              BJJ: address
            } : {}), tokenIds ? {
              tokenIds: tokenIds.join(',')
            } : {}), _getPageData(fromItem, order, limit));
            return _context.abrupt("return", (0, _http.extractJSON)(_axios.default.get("".concat(baseApiUrl, "/accounts"), {
              params: params
            })));

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getAccounts.apply(this, arguments);
}

function getAccount(_x4) {
  return _getAccount.apply(this, arguments);
}
/**
 * GET request to the /transactions-histroy endpoint. Returns a list of forged transaction based on certain filters
 * @param {String} address - Filter by the address that sent or received the transactions. It can be a Hermez Ethereum address or a Hermez BabyJubJub address
 * @param {Number[]} tokenIds - Array of token IDs as registered in the network
 * @param {Number} batchNum - Filter by batch number
 * @param {String} accountIndex - Filter by an account index that sent or received the transactions
 * @param {Number} fromItem - Item from where to start the request
 * @returns {Object} Response data with filtered transactions and pagination data
 */


function _getAccount() {
  _getAccount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(accountIndex) {
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", (0, _http.extractJSON)(_axios.default.get("".concat(baseApiUrl, "/accounts/").concat(accountIndex))));

          case 1:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _getAccount.apply(this, arguments);
}

function getTransactions(_x5, _x6, _x7, _x8, _x9) {
  return _getTransactions.apply(this, arguments);
}
/**
 * GET request to the /transactions-history/:transactionId endpoint. Returns a specific forged transaction
 * @param {String} transactionId - The ID for the specific transaction
 * @returns {Object} Response data with the transaction
 */


function _getTransactions() {
  _getTransactions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(address, tokenIds, batchNum, accountIndex, fromItem) {
    var order,
        limit,
        params,
        _args3 = arguments;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            order = _args3.length > 5 && _args3[5] !== undefined ? _args3[5] : PaginationOrder.ASC;
            limit = _args3.length > 6 && _args3[6] !== undefined ? _args3[6] : _constants.DEFAULT_PAGE_SIZE;
            params = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, (0, _addresses.isHermezEthereumAddress)(address) ? {
              hezEthereumAddress: address
            } : {}), (0, _addresses.isHermezBjjAddress)(address) ? {
              BJJ: address
            } : {}), tokenIds ? {
              tokenIds: tokenIds.join(',')
            } : {}), batchNum ? {
              batchNum: batchNum
            } : {}), accountIndex ? {
              accountIndex: accountIndex
            } : {}), _getPageData(fromItem, order, limit));
            return _context3.abrupt("return", (0, _http.extractJSON)(_axios.default.get("".concat(baseApiUrl, "/transactions-history"), {
              params: params
            })));

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _getTransactions.apply(this, arguments);
}

function getHistoryTransaction(_x10) {
  return _getHistoryTransaction.apply(this, arguments);
}
/**
 * GET request to the /transactions-pool/:transactionId endpoint. Returns a specific unforged transaction
 * @param {String} transactionId - The ID for the specific transaction
 * @returns {Object} Response data with the transaction
 */


function _getHistoryTransaction() {
  _getHistoryTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(transactionId) {
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.abrupt("return", (0, _http.extractJSON)(_axios.default.get("".concat(baseApiUrl, "/transactions-history/").concat(transactionId))));

          case 1:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _getHistoryTransaction.apply(this, arguments);
}

function getPoolTransaction(_x11) {
  return _getPoolTransaction.apply(this, arguments);
}
/**
 * POST request to the /transaction-pool endpoint. Sends an L2 transaction to the network
 * @param {Object} transaction - Transaction data returned by TxUtils.generateL2Transaction
 * @returns {String} Transaction id
 */


function _getPoolTransaction() {
  _getPoolTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(transactionId) {
    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            return _context5.abrupt("return", (0, _http.extractJSON)(_axios.default.get("".concat(baseApiUrl, "/transactions-pool/").concat(transactionId))));

          case 1:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _getPoolTransaction.apply(this, arguments);
}

function postPoolTransaction(_x12) {
  return _postPoolTransaction.apply(this, arguments);
}
/**
 * GET request to the /exits endpoint. Returns a list of exits based on certain filters
 * @param {String} address - Filter by the address associated to the exits. It can be a Hermez Ethereum address or a Hermez BabyJubJub address
 * @param {Boolean} onlyPendingWithdraws - Filter by exits that still haven't been withdrawn
 * @returns {Object} Response data with the list of exits
 */


function _postPoolTransaction() {
  _postPoolTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(transaction) {
    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            return _context6.abrupt("return", _axios.default.post("".concat(baseApiUrl, "/transactions-pool"), transaction));

          case 1:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _postPoolTransaction.apply(this, arguments);
}

function getExits(_x13, _x14) {
  return _getExits.apply(this, arguments);
}
/**
 * GET request to the /exits/:batchNum/:accountIndex endpoint. Returns a specific exit
 * @param {Number} batchNum - Filter by an exit in a specific batch number
 * @param {String} accountIndex - Filter by an exit associated to an account index
 * @returns {Object} Response data with the specific exit
 */


function _getExits() {
  _getExits = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(address, onlyPendingWithdraws) {
    var params;
    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            params = _objectSpread(_objectSpread(_objectSpread({}, (0, _addresses.isHermezEthereumAddress)(address) ? {
              hezEthereumAddress: address
            } : {}), (0, _addresses.isHermezBjjAddress)(address) ? {
              BJJ: address
            } : {}), onlyPendingWithdraws ? {
              onlyPendingWithdraws: onlyPendingWithdraws
            } : {});
            return _context7.abrupt("return", (0, _http.extractJSON)(_axios.default.get("".concat(baseApiUrl, "/exits"), {
              params: params
            })));

          case 2:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _getExits.apply(this, arguments);
}

function getExit(_x15, _x16) {
  return _getExit.apply(this, arguments);
}
/**
 * GET request to the /tokens endpoint. Returns a list of token data
 * @param {number[]} tokenIds - An array of token IDs
 * @returns {Object} Response data with the list of tokens
 */


function _getExit() {
  _getExit = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(batchNum, accountIndex) {
    return regeneratorRuntime.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return (0, _http.extractJSON)(_axios.default.get("".concat(baseApiUrl, "/exits/").concat(batchNum, "/").concat(accountIndex)));

          case 2:
            return _context8.abrupt("return", _context8.sent);

          case 3:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));
  return _getExit.apply(this, arguments);
}

function getTokens(_x17, _x18) {
  return _getTokens.apply(this, arguments);
}
/**
 * GET request to the /tokens/:tokenId endpoint. Returns a specific token
 * @param {Number} tokenId - A token ID
 * @returns {Object} Response data with a specific token
 */


function _getTokens() {
  _getTokens = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(tokenIds, fromItem) {
    var order,
        limit,
        params,
        _args9 = arguments;
    return regeneratorRuntime.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            order = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : PaginationOrder.ASC;
            limit = _args9.length > 3 && _args9[3] !== undefined ? _args9[3] : _constants.DEFAULT_PAGE_SIZE;
            params = _objectSpread(_objectSpread({}, tokenIds ? {
              ids: tokenIds.join(',')
            } : {}), _getPageData(fromItem, order, limit));
            return _context9.abrupt("return", (0, _http.extractJSON)(_axios.default.get("".concat(baseApiUrl, "/tokens"), {
              params: params
            })));

          case 4:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));
  return _getTokens.apply(this, arguments);
}

function getToken(_x19) {
  return _getToken.apply(this, arguments);
}
/**
 * GET request to the /state endpoint.
 * @returns {Object} Response data with the current state of the coordinator
 */


function _getToken() {
  _getToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(tokenId) {
    return regeneratorRuntime.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            return _context10.abrupt("return", (0, _http.extractJSON)(_axios.default.get("".concat(baseApiUrl, "/tokens/").concat(tokenId))));

          case 1:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10);
  }));
  return _getToken.apply(this, arguments);
}

function getState() {
  return _getState.apply(this, arguments);
}
/**
 * GET request to the /batches endpoint. Returns a filtered list of batches
 * @param {String} forgerAddr - Filter by forger address
 * @param {Number} slotNum - A specific slot number
 * @param {Number} fromItem - Item from where to start the request
 * @returns {Object} Response data with a paginated list of batches
 */


function _getState() {
  _getState = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
    var state;
    return regeneratorRuntime.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            _context11.next = 2;
            return (0, _http.extractJSON)(_axios.default.get("".concat(baseApiUrl, "/state")));

          case 2:
            state = _context11.sent;
            state.network.nextForgers = [{
              coordinator: {
                URL: 'http://localhost:8086'
              }
            }];
            return _context11.abrupt("return", state);

          case 5:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11);
  }));
  return _getState.apply(this, arguments);
}

function getBatches(_x20, _x21, _x22) {
  return _getBatches.apply(this, arguments);
}
/**
 * GET request to the /batches/:batchNum endpoint. Returns a specific batch
 * @param {Number} batchNum - Number of a specific batch
 * @returns {Object} Response data with a specific batch
 */


function _getBatches() {
  _getBatches = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(forgerAddr, slotNum, fromItem) {
    var order,
        limit,
        params,
        _args12 = arguments;
    return regeneratorRuntime.wrap(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            order = _args12.length > 3 && _args12[3] !== undefined ? _args12[3] : PaginationOrder.ASC;
            limit = _args12.length > 4 && _args12[4] !== undefined ? _args12[4] : _constants.DEFAULT_PAGE_SIZE;
            params = _objectSpread(_objectSpread(_objectSpread({}, forgerAddr ? {
              forgerAddr: forgerAddr
            } : {}), slotNum ? {
              slotNum: slotNum
            } : {}), _getPageData(fromItem, order, limit));
            return _context12.abrupt("return", (0, _http.extractJSON)(_axios.default.get("".concat(baseApiUrl, "/batches"), {
              params: params
            })));

          case 4:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee12);
  }));
  return _getBatches.apply(this, arguments);
}

function getBatch(_x23) {
  return _getBatch.apply(this, arguments);
}
/**
 * GET request to the /coordinators/:bidderAddr endpoint. Returns a specific coordinator information
 * @param {String} forgerAddr - A coordinator forger address
 * @param {String} bidderAddr - A coordinator bidder address
 * @returns {Object} Response data with a specific coordinator
 */


function _getBatch() {
  _getBatch = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(batchNum) {
    return regeneratorRuntime.wrap(function _callee13$(_context13) {
      while (1) {
        switch (_context13.prev = _context13.next) {
          case 0:
            return _context13.abrupt("return", (0, _http.extractJSON)(_axios.default.get("".concat(baseApiUrl, "/batches/").concat(batchNum))));

          case 1:
          case "end":
            return _context13.stop();
        }
      }
    }, _callee13);
  }));
  return _getBatch.apply(this, arguments);
}

function getCoordinators(_x24, _x25) {
  return _getCoordinators.apply(this, arguments);
}
/**
 * GET request to the /slots/:slotNum endpoint. Returns the information for a specific slot
 * @param {Number} slotNum - The nunmber of a slot
 * @returns {Object} Response data with a specific slot
 */


function _getCoordinators() {
  _getCoordinators = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(forgerAddr, bidderAddr) {
    var params;
    return regeneratorRuntime.wrap(function _callee14$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            params = _objectSpread(_objectSpread({}, forgerAddr ? {
              forgerAddr: forgerAddr
            } : {}), bidderAddr ? {
              bidderAddr: bidderAddr
            } : {});
            return _context14.abrupt("return", (0, _http.extractJSON)(_axios.default.get("".concat(baseApiUrl, "/coordinators"), {
              params: params
            })));

          case 2:
          case "end":
            return _context14.stop();
        }
      }
    }, _callee14);
  }));
  return _getCoordinators.apply(this, arguments);
}

function getSlot(_x26) {
  return _getSlot.apply(this, arguments);
}
/**
 * GET request to the /bids endpoint. Returns a list of bids
 * @param {Number} slotNum - Filter by slot
 * @param {String} bidderAddr - Filter by coordinator
 * @param {Number} fromItem - Item from where to start the request
 * @returns {Object} Response data with the list of slots
 */


function _getSlot() {
  _getSlot = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(slotNum) {
    return regeneratorRuntime.wrap(function _callee15$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            return _context15.abrupt("return", (0, _http.extractJSON)(_axios.default.get("".concat(baseApiUrl, "/slots/").concat(slotNum))));

          case 1:
          case "end":
            return _context15.stop();
        }
      }
    }, _callee15);
  }));
  return _getSlot.apply(this, arguments);
}

function getBids(_x27, _x28, _x29) {
  return _getBids.apply(this, arguments);
}
/**
 * POST request to the /account-creation-authorization endpoint. Sends an authorization to the coordinator to register token accounts on their behalf
 * @param {String} hezEthereumAddress - The Hermez Ethereum address of the account that makes the authorization
 * @param {String} bJJ - BabyJubJub address of the account that makes the authorization
 * @param {String} signature - The signature of the request
 * @returns {Object} Response data
 */


function _getBids() {
  _getBids = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(slotNum, bidderAddr, fromItem) {
    var order,
        limit,
        params,
        _args16 = arguments;
    return regeneratorRuntime.wrap(function _callee16$(_context16) {
      while (1) {
        switch (_context16.prev = _context16.next) {
          case 0:
            order = _args16.length > 3 && _args16[3] !== undefined ? _args16[3] : PaginationOrder.ASC;
            limit = _args16.length > 4 && _args16[4] !== undefined ? _args16[4] : _constants.DEFAULT_PAGE_SIZE;
            params = _objectSpread(_objectSpread(_objectSpread({}, slotNum ? {
              slotNum: slotNum
            } : {}), bidderAddr ? {
              bidderAddr: bidderAddr
            } : {}), _getPageData(fromItem, order, limit));
            return _context16.abrupt("return", (0, _http.extractJSON)(_axios.default.get("".concat(baseApiUrl, "/bids"), {
              params: params
            })));

          case 4:
          case "end":
            return _context16.stop();
        }
      }
    }, _callee16);
  }));
  return _getBids.apply(this, arguments);
}

function postCreateAccountAuthorization(_x30, _x31, _x32) {
  return _postCreateAccountAuthorization.apply(this, arguments);
}

function _postCreateAccountAuthorization() {
  _postCreateAccountAuthorization = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(hezEthereumAddress, bJJ, signature) {
    return regeneratorRuntime.wrap(function _callee17$(_context17) {
      while (1) {
        switch (_context17.prev = _context17.next) {
          case 0:
            return _context17.abrupt("return", _axios.default.post("".concat(baseApiUrl, "/account-creation-authorization"), {
              hezEthereumAddress: hezEthereumAddress,
              bjj: bJJ,
              signature: signature
            }));

          case 1:
          case "end":
            return _context17.stop();
        }
      }
    }, _callee17);
  }));
  return _postCreateAccountAuthorization.apply(this, arguments);
}