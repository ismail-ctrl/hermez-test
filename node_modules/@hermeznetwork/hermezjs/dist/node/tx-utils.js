"use strict";

require("core-js/modules/es.array.filter.js");

require("core-js/modules/es.array.find.js");

require("core-js/modules/es.array.includes.js");

require("core-js/modules/es.array.index-of.js");

require("core-js/modules/es.array.map.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.array-buffer.constructor.js");

require("core-js/modules/es.array-buffer.slice.js");

require("core-js/modules/es.number.constructor.js");

require("core-js/modules/es.object.assign.js");

require("core-js/modules/es.object.keys.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.to-string.js");

require("core-js/modules/es.string.includes.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._encodeTransaction = encodeTransaction;
exports.getTxId = getTxId;
exports.getFee = getFee;
exports.getTransactionType = getTransactionType;
exports.getNonce = getNonce;
exports._buildTxCompressedData = buildTxCompressedData;
exports.buildTransactionHashMessage = buildTransactionHashMessage;
exports.generateL2Transaction = generateL2Transaction;
exports.beautifyTransactionState = beautifyTransactionState;
exports.TxState = exports.TxType = void 0;

require("regenerator-runtime/runtime.js");

var _bigInteger = _interopRequireDefault(require("big-integer"));

var _ffjavascript = require("ffjavascript");

var _circomlib = _interopRequireDefault(require("circomlib"));

var _feeFactors = require("./fee-factors.js");

var _utils = require("./utils.js");

var _float = require("./float16.js");

var _txPool = require("./tx-pool.js");

var _addresses = require("./addresses.js");

var _api = require("./api.js");

var _providers = require("./providers.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var TxType = {
  Deposit: 'Deposit',
  CreateAccountDeposit: 'CreateAccountDeposit',
  Transfer: 'Transfer',
  Withdraw: 'Withdrawn',
  Exit: 'Exit',
  ForceExit: 'ForceExit'
};
exports.TxType = TxType;
var TxState = {
  Forged: 'fged',
  Forging: 'fing',
  Pending: 'pend',
  Invalid: 'invl'
};
/**
 * Encodes the transaction object to be in a format supported by the Smart Contracts and Circuits.
 * Used, for example, to sign the transaction
 * @param {Object} transaction - Transaction object returned by generateL2Transaction
 * @param {String} providerUrl - Network url (i.e, http://localhost:8545). Optional
 * @returns {Object} encodedTransaction
 * @private
 */

exports.TxState = TxState;

function encodeTransaction(_x, _x2) {
  return _encodeTransaction.apply(this, arguments);
}
/**
 * Generates the correct Transaction Id based on the spec
 * TxID (12 bytes) for L2Tx is:
 * bytes:  |  1   |    6    |   5   |
 * values: | type | FromIdx | Nonce |
 * where type for L2Tx is '2'
 * @param {Number} fromIdx - The account index that sends the transaction
 * @param {Number} nonce - Nonce of the transaction
 * @returns {String} Transaction Id
 */


function _encodeTransaction() {
  _encodeTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(transaction, providerUrl) {
    var encodedTransaction, provider;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            encodedTransaction = Object.assign({}, transaction);
            provider = (0, _providers.getProvider)(providerUrl);
            _context.next = 4;
            return provider.getNetwork();

          case 4:
            encodedTransaction.chainId = _context.sent.chainId;
            encodedTransaction.fromAccountIndex = (0, _addresses.getAccountIndex)(transaction.fromAccountIndex);

            if (transaction.toAccountIndex) {
              encodedTransaction.toAccountIndex = (0, _addresses.getAccountIndex)(transaction.toAccountIndex);
            } else if (transaction.type === 'Exit') {
              encodedTransaction.toAccountIndex = 1;
            }

            return _context.abrupt("return", encodedTransaction);

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _encodeTransaction.apply(this, arguments);
}

function getTxId(fromIdx, nonce) {
  var fromIdxBytes = new ArrayBuffer(8);
  var fromIdxView = new DataView(fromIdxBytes);
  fromIdxView.setBigUint64(0, (0, _bigInteger.default)(fromIdx).value, false);
  var nonceBytes = new ArrayBuffer(8);
  var nonceView = new DataView(nonceBytes);
  nonceView.setBigUint64(0, (0, _bigInteger.default)(nonce).value, false);
  var fromIdxHex = (0, _utils.bufToHex)(fromIdxView.buffer.slice(2, 8));
  var nonceHex = (0, _utils.bufToHex)(nonceView.buffer.slice(3, 8));
  return '0x02' + fromIdxHex + nonceHex;
}
/**
 * Calculates the appropriate fee factor depending on what's the fee as a percentage of the amount
 * @param {Number} fee - The fee in token value
 * @param {String} amount - The amount as a BigInt string
 * @return {Number} feeFactor
 */


function getFee(fee, amount, decimals) {
  var amountFloat = Number(amount) / Math.pow(10, decimals);
  var percentage = fee / amountFloat;
  var low = 0;
  var mid;
  var high = _feeFactors.feeFactors.length - 1;

  while (high - low > 1) {
    mid = Math.floor((low + high) / 2);

    if (_feeFactors.feeFactors[mid] < percentage) {
      low = mid;
    } else {
      high = mid;
    }
  }

  return high;
}
/**
 * Gets the transaction type depending on the information in the transaction object
 * If an account index is used, it will be 'Transfer'
 * If a Hermez address is used, it will be 'TransferToEthAddr'
 * If a BabyJubJub is used, it will be 'TransferToBjj'
 * @param {Object} transaction - Transaction object sent to generateL2Transaction
 * @return {String} transactionType
 */


function getTransactionType(transaction) {
  if (transaction.to && transaction.to.includes('hez:')) {
    return 'Transfer';
  } else {
    return 'Exit';
  }
}
/**
 * Calculates the appropriate nonce based on the current token account nonce and existing transactions in the Pool.
 * It needs to find the lowest nonce available as transactions in the pool may fail and the Coordinator only forges
 * transactions in the order set by nonces.
 * @param {Number} currentNonce - The current token account nonce returned by the Coordinator (optional)
 * @param {String} accountIndex - The account index
 * @param {Number} tokenId - The token id of the token in the transaction
 * @return {Number} nonce
 */


function getNonce(_x3, _x4, _x5, _x6) {
  return _getNonce.apply(this, arguments);
}
/**
 * Encode tx compressed data
 * @param {Object} tx - Transaction object returned by `encodeTransaction`
 * @returns {Scalar} Encoded tx compressed data
 * @private
 */


function _getNonce() {
  _getNonce = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(currentNonce, accountIndex, bjj, tokenId) {
    var poolTxs, poolTxsNonces, nonce, accountData;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return (0, _txPool.getPoolTransactions)(accountIndex, bjj);

          case 2:
            poolTxs = _context2.sent;
            poolTxsNonces = poolTxs.filter(function (tx) {
              return tx.token.id === tokenId;
            }).map(function (tx) {
              return tx.nonce;
            }).sort();
            nonce = currentNonce;

            if (!(typeof nonce === 'undefined')) {
              _context2.next = 11;
              break;
            }

            _context2.next = 8;
            return (0, _api.getAccount)(accountIndex);

          case 8:
            accountData = _context2.sent;
            nonce = accountData.nonce; // return current nonce if no transactions are pending

            if (poolTxsNonces.length) {
              while (poolTxsNonces.indexOf(nonce) !== -1) {
                nonce++;
              }
            }

          case 11:
            return _context2.abrupt("return", nonce);

          case 12:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _getNonce.apply(this, arguments);
}

function buildTxCompressedData(tx) {
  var signatureConstant = _ffjavascript.Scalar.fromString('3322668559');

  var res = _ffjavascript.Scalar.e(0);

  res = _ffjavascript.Scalar.add(res, signatureConstant); // SignConst --> 32 bits

  res = _ffjavascript.Scalar.add(res, _ffjavascript.Scalar.shl(tx.chainId || 0, 32)); // chainId --> 16 bits

  res = _ffjavascript.Scalar.add(res, _ffjavascript.Scalar.shl(tx.fromAccountIndex || 0, 48)); // fromIdx --> 48 bits

  res = _ffjavascript.Scalar.add(res, _ffjavascript.Scalar.shl(tx.toAccountIndex || 0, 96)); // toIdx --> 48 bits

  res = _ffjavascript.Scalar.add(res, _ffjavascript.Scalar.shl((0, _float.fix2Float)(tx.amount || 0), 144)); // amounf16 --> 16 bits

  res = _ffjavascript.Scalar.add(res, _ffjavascript.Scalar.shl(tx.tokenId || 0, 160)); // tokenID --> 32 bits

  res = _ffjavascript.Scalar.add(res, _ffjavascript.Scalar.shl(tx.nonce || 0, 192)); // nonce --> 40 bits

  res = _ffjavascript.Scalar.add(res, _ffjavascript.Scalar.shl(tx.fee || 0, 232)); // userFee --> 8 bits

  res = _ffjavascript.Scalar.add(res, _ffjavascript.Scalar.shl(tx.toBjjSign ? 1 : 0, 240)); // toBjjSign --> 1 bit

  return res;
}
/**
 * Build element_1 for L2HashSignature
 * @param {Object} tx - Transaction object returned by `encodeTransaction`
 * @returns {Scalar} element_1 L2 signature
 */


function buildElement1(tx) {
  var res = _ffjavascript.Scalar.e(0);

  res = _ffjavascript.Scalar.add(res, _ffjavascript.Scalar.fromString(tx.toEthAddr || '0', 16)); // ethAddr --> 160 bits

  res = _ffjavascript.Scalar.add(res, _ffjavascript.Scalar.shl(tx.maxNumBatch || 0, 160)); // maxNumBatch --> 32 bits

  return res;
}
/**
 * Builds the message to hash. Used when signing transactions
 * @param {Object} encodedTransaction - Transaction object return from `encodeTransaction`
 * @returns {Scalar} Message to sign
 */


function buildTransactionHashMessage(encodedTransaction) {
  var txCompressedData = buildTxCompressedData(encodedTransaction);
  var element1 = buildElement1(encodedTransaction);

  var h = _circomlib.default.poseidon([txCompressedData, element1, _ffjavascript.Scalar.fromString(encodedTransaction.toBjjAy || '0', 16), _ffjavascript.Scalar.e(encodedTransaction.rqTxCompressedDataV2 || 0), _ffjavascript.Scalar.fromString(encodedTransaction.rqToEthAddr || '0', 16), _ffjavascript.Scalar.fromString(encodedTransaction.rqToBjjAy || '0', 16)]);

  return h;
}
/**
 * Prepares a transaction to be ready to be sent to a Coordinator.
 * @param {Object} transaction - ethAddress and babyPubKey together
 * @param {String} transaction.from - The account index that's sending the transaction e.g hez:DAI:4444
 * @param {String} transaction.to - The account index of the receiver e.g hez:DAI:2156. If it's an Exit, set to a falseable value
 * @param {BigInt} transaction.amount - The amount being sent as a BigInt
 * @param {Number} transaction.fee - The amount of tokens to be sent as a fee to the Coordinator
 * @param {Number} transaction.nonce - The current nonce of the sender's token account (optional)
 * @param {String} bjj - The compressed BabyJubJub in hexadecimal format of the transaction sender
 * @param {Object} token - The token information object as returned from the Coordinator.
 * @return {Object} - Contains `transaction` and `encodedTransaction`. `transaction` is the object almost ready to be sent to the Coordinator. `encodedTransaction` is needed to sign the `transaction`
*/


function generateL2Transaction(_x7, _x8, _x9) {
  return _generateL2Transaction.apply(this, arguments);
}
/**
 * Gets the beautified name of a transaction state
 * @param {String} transactionState - The original transaction state from the API
 * @return {String} - The beautified transaction state
*/


function _generateL2Transaction() {
  _generateL2Transaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(tx, bjj, token) {
    var transaction, encodedTransaction;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.t0 = getTransactionType(tx);
            _context3.t1 = token.id;
            _context3.t2 = tx.from;
            _context3.t3 = tx.type === 'Exit' ? "hez:".concat(token.symbol, ":1") : tx.to;
            _context3.t4 = (0, _float.float2Fix)((0, _float.floorFix2Float)(tx.amount)).toString();
            _context3.t5 = getFee(tx.fee, tx.amount, token.decimals);
            _context3.next = 8;
            return getNonce(tx.nonce, tx.from, bjj, token.id);

          case 8:
            _context3.t6 = _context3.sent;
            transaction = {
              type: _context3.t0,
              tokenId: _context3.t1,
              fromAccountIndex: _context3.t2,
              toAccountIndex: _context3.t3,
              toHezEthereumAddress: null,
              toBjj: null,
              amount: _context3.t4,
              fee: _context3.t5,
              nonce: _context3.t6,
              requestFromAccountIndex: null,
              requestToAccountIndex: null,
              requestToHezEthereumAddress: null,
              requestToBjj: null,
              requestTokenId: null,
              requestAmount: null,
              requestFee: null,
              requestNonce: null
            };
            _context3.next = 12;
            return encodeTransaction(transaction);

          case 12:
            encodedTransaction = _context3.sent;
            transaction.id = getTxId(encodedTransaction.fromAccountIndex, encodedTransaction.nonce);
            return _context3.abrupt("return", {
              transaction: transaction,
              encodedTransaction: encodedTransaction
            });

          case 15:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _generateL2Transaction.apply(this, arguments);
}

function beautifyTransactionState(transactionState) {
  return Object.keys(TxState).find(function (key) {
    return TxState[key] === transactionState;
  });
}