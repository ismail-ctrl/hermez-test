"use strict";

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.join.js");

require("core-js/modules/es.array.map.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.array-buffer.slice.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.regexp.to-string.js");

require("core-js/modules/es.string.match.js");

require("core-js/modules/es.string.repeat.js");

require("core-js/modules/es.typed-array.uint8-array.js");

require("core-js/modules/es.typed-array.copy-within.js");

require("core-js/modules/es.typed-array.every.js");

require("core-js/modules/es.typed-array.fill.js");

require("core-js/modules/es.typed-array.filter.js");

require("core-js/modules/es.typed-array.find.js");

require("core-js/modules/es.typed-array.find-index.js");

require("core-js/modules/es.typed-array.for-each.js");

require("core-js/modules/es.typed-array.includes.js");

require("core-js/modules/es.typed-array.index-of.js");

require("core-js/modules/es.typed-array.iterator.js");

require("core-js/modules/es.typed-array.join.js");

require("core-js/modules/es.typed-array.last-index-of.js");

require("core-js/modules/es.typed-array.map.js");

require("core-js/modules/es.typed-array.reduce.js");

require("core-js/modules/es.typed-array.reduce-right.js");

require("core-js/modules/es.typed-array.reverse.js");

require("core-js/modules/es.typed-array.set.js");

require("core-js/modules/es.typed-array.slice.js");

require("core-js/modules/es.typed-array.some.js");

require("core-js/modules/es.typed-array.sort.js");

require("core-js/modules/es.typed-array.subarray.js");

require("core-js/modules/es.typed-array.to-locale-string.js");

require("core-js/modules/es.typed-array.to-string.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bufToHex = bufToHex;
exports.getTokenAmountString = getTokenAmountString;
exports.getTokenAmountBigInt = getTokenAmountBigInt;
exports.padZeros = padZeros;
exports.hexToBuffer = void 0;

var _ethers = require("ethers");

/**
 * Converts a buffer to a hexadecimal representation
 * @param {ArrayBuffer} buf
 * @returns {String}
 */
function bufToHex(buf) {
  return Array.prototype.map.call(new Uint8Array(buf), function (x) {
    return ('00' + x.toString(16)).slice(-2);
  }).join('');
}

var hexToBuffer = function hexToBuffer(hexString) {
  return Buffer.from(hexString.match(/.{1,2}/g).map(function (byte) {
    return parseInt(byte, 16);
  }));
};
/**
 * Converts an amount in BigInt and decimals to a String with correct decimal point placement
 * @param {String} amountBigInt - String representing the amount as a BigInt with no decimals
 * @param {Number} decimals - Number of decimal points the amount actually has
 * @returns {String}
 */


exports.hexToBuffer = hexToBuffer;

function getTokenAmountString(amountBigInt, decimals) {
  return _ethers.ethers.utils.formatUnits(amountBigInt, decimals);
}
/**
 * Converts an amount in Float with the appropriate decimals to a BigInt
 * @param {String} amountString - String representing the amount as a Float
 * @param {Number} decimals - Number of decimal points the amount has
 * @returns {BigInt}
 */


function getTokenAmountBigInt(amountString, decimals) {
  return _ethers.ethers.utils.parseUnits(amountString, decimals);
}
/**
 * Pad a string hex number with 0
 * @param {String} string - String input
 * @param {Number} length - Length of the resulting string
 * @returns {String} Resulting string
 */


function padZeros(string, length) {
  if (length > string.length) {
    string = '0'.repeat(length - string.length) + string;
  }

  return string;
}