"use strict";

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.to-string.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sendL2Transaction = sendL2Transaction;
exports.generateAndSendL2Tx = generateAndSendL2Tx;
exports.delayedWithdraw = exports.withdraw = exports.forceExit = exports.deposit = void 0;

require("regenerator-runtime/runtime.js");

var _ffjavascript = require("ffjavascript");

var _api = require("./api.js");

var _float = require("./float16.js");

var _txPool = require("./tx-pool.js");

var _constants = require("./constants.js");

var _tokens = require("./tokens.js");

var _addresses = require("./addresses.js");

var _contracts = require("./contracts.js");

var _providers = require("./providers.js");

var _txUtils = require("./tx-utils.js");

var _HermezABI = _interopRequireDefault(require("./abis/HermezABI.js"));

var _WithdrawalDelayerABI = _interopRequireDefault(require("./abis/WithdrawalDelayerABI.js"));

var _signers = require("./signers.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/**
 * Get current average gas price from the last ethereum blocks and multiply it
 * @param {Number} multiplier - multiply the average gas price by this parameter
 * @param {String} providerUrl - Network url (i.e, http://localhost:8545). Optional
 * @returns {Promise} - promise will return the gas price obtained.
 */
function getGasPrice(_x, _x2) {
  return _getGasPrice.apply(this, arguments);
}
/**
 * Makes a deposit.
 * It detects if it's a 'createAccountDeposit' or a 'deposit' and prepares the parameters accodingly.
 * Detects if it's an Ether, ERC 20 or ERC 777 token and sends the transaction accordingly.
 * @param {BigInt} amount - The amount to be deposited
 * @param {String} hezEthereumAddress - The Hermez address of the transaction sender
 * @param {Object} token - The token information object as returned from the API
 * @param {String} babyJubJub - The compressed BabyJubJub in hexadecimal format of the transaction sender.
 * @param {String} providerUrl - Network url (i.e, http://localhost:8545). Optional
 * @param {Object} signerData - Signer data used to build a Signer to send the transaction
 * @param {Number} gasLimit - Optional gas limit
 * @param {Number} gasMultiplier - Optional gas multiplier
 * @returns {Promise} transaction parameters
 */


function _getGasPrice() {
  _getGasPrice = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(multiplier, providerUrl) {
    var provider, strAvgGas, avgGas, res, retValue;
    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            provider = (0, _providers.getProvider)(providerUrl);
            _context5.next = 3;
            return provider.getGasPrice();

          case 3:
            strAvgGas = _context5.sent;
            avgGas = _ffjavascript.Scalar.e(strAvgGas);
            res = avgGas * _ffjavascript.Scalar.e(multiplier);
            retValue = res.toString();
            return _context5.abrupt("return", retValue);

          case 8:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _getGasPrice.apply(this, arguments);
}

var deposit = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(amount, hezEthereumAddress, token, babyJubJub, providerUrl, signerData) {
    var gasLimit,
        gasMultiplier,
        ethereumAddress,
        txSignerData,
        hermezContract,
        accounts,
        account,
        overrides,
        transactionParameters,
        _args = arguments;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            gasLimit = _args.length > 6 && _args[6] !== undefined ? _args[6] : _constants.GAS_LIMIT;
            gasMultiplier = _args.length > 7 && _args[7] !== undefined ? _args[7] : _constants.GAS_MULTIPLIER;
            ethereumAddress = (0, _addresses.getEthereumAddress)(hezEthereumAddress);
            txSignerData = signerData || {
              type: _signers.SignerType.JSON_RPC,
              addressOrIndex: ethereumAddress
            };
            hermezContract = (0, _contracts.getContract)(_constants.contractAddresses.Hermez, _HermezABI.default, providerUrl, txSignerData);
            _context.next = 7;
            return (0, _api.getAccounts)(hezEthereumAddress, [token.id]).catch(function () {
              return undefined;
            });

          case 7:
            accounts = _context.sent;
            account = typeof accounts !== 'undefined' ? accounts.accounts[0] : null;
            _context.t0 = gasLimit;
            _context.next = 12;
            return getGasPrice(gasMultiplier, providerUrl);

          case 12:
            _context.t1 = _context.sent;
            overrides = {
              gasLimit: _context.t0,
              gasPrice: _context.t1
            };
            transactionParameters = [account ? 0 : "0x".concat(babyJubJub), account ? (0, _addresses.getAccountIndex)(account.accountIndex) : 0, (0, _float.fix2Float)(amount), 0, token.id, 0, '0x'];

            if (!(token.id === 0)) {
              _context.next = 18;
              break;
            }

            overrides.value = amount;
            return _context.abrupt("return", hermezContract.addL1Transaction.apply(hermezContract, transactionParameters.concat([overrides])).then(function () {
              return transactionParameters;
            }));

          case 18:
            _context.next = 20;
            return (0, _tokens.approve)(amount, ethereumAddress, token.ethereumAddress, providerUrl, signerData);

          case 20:
            return _context.abrupt("return", hermezContract.addL1Transaction.apply(hermezContract, transactionParameters.concat([overrides])).then(function () {
              return transactionParameters;
            }));

          case 21:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function deposit(_x3, _x4, _x5, _x6, _x7, _x8) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Makes a force Exit. This is the L1 transaction equivalent of Exit.
 * @param {BigInt} amount - The amount to be withdrawn
 * @param {String} accountIndex - The account index in hez address format e.g. hez:DAI:4444
 * @param {Object} token - The token information object as returned from the API
 * @param {String} providerUrl - Network url (i.e, http://localhost:8545). Optional
 * @param {Object} signerData - Signer data used to build a Signer to send the transaction
 * @param {Number} gasLimit - Optional gas limit
 * @param {Number} gasMultiplier - Optional gas multiplier
 * @returns {Promise} transaction parameters
 * @throws {Error} Throws an error if account index isn't valid
 */


exports.deposit = deposit;

var forceExit = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(amount, accountIndex, token, providerUrl, signerData) {
    var gasLimit,
        gasMultiplier,
        account,
        ethereumAddress,
        txSignerData,
        hermezContract,
        overrides,
        transactionParameters,
        _args2 = arguments;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            gasLimit = _args2.length > 5 && _args2[5] !== undefined ? _args2[5] : _constants.GAS_LIMIT;
            gasMultiplier = _args2.length > 6 && _args2[6] !== undefined ? _args2[6] : _constants.GAS_MULTIPLIER;
            _context2.next = 4;
            return (0, _api.getAccount)(accountIndex).catch(function () {
              throw new Error('Invalid account index');
            });

          case 4:
            account = _context2.sent;
            ethereumAddress = (0, _addresses.getEthereumAddress)(account.hezEthereumAddress);
            txSignerData = signerData || {
              type: _signers.SignerType.JSON_RPC,
              addressOrIndex: ethereumAddress
            };
            hermezContract = (0, _contracts.getContract)(_constants.contractAddresses.Hermez, _HermezABI.default, providerUrl, txSignerData);
            _context2.t0 = gasLimit;
            _context2.next = 11;
            return getGasPrice(gasMultiplier, providerUrl);

          case 11:
            _context2.t1 = _context2.sent;
            overrides = {
              gasLimit: _context2.t0,
              gasPrice: _context2.t1
            };
            transactionParameters = [0, (0, _addresses.getAccountIndex)(accountIndex), 0, (0, _float.fix2Float)(amount), token.id, 1, '0x'];
            return _context2.abrupt("return", hermezContract.addL1Transaction.apply(hermezContract, transactionParameters.concat([overrides])).then(function () {
              return transactionParameters;
            }));

          case 15:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function forceExit(_x9, _x10, _x11, _x12, _x13) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Finalise the withdraw. This is a L1 transaction.
 * @param {BigInt} amount - The amount to be withdrawn
 * @param {String} accountIndex - The account index in hez address format e.g. hez:DAI:4444
 * @param {Object} token - The token information object as returned from the API
 * @param {String} babyJubJub - The compressed BabyJubJub in hexadecimal format of the transaction sender.
 * @param {BigInt} batchNumber - The batch number where the exit being withdrawn was forged
 * @param {Array} merkleSiblings - An array of BigInts representing the siblings of the exit being withdrawn.
 * @param {String} providerUrl - Network url (i.e, http://localhost:8545). Optional
 * @param {Object} signerData - Signer data used to build a Signer to send the transaction
 * @param {Boolean} isInstant - Whether it should be an Instant Withdrawal
 * @param {Boolean} filterSiblings - Whether siblings should be filtered
 * @param {Number} gasLimit - Optional gas limit
 * @param {Number} gasMultiplier - Optional gas multiplier
 * @returns {Promise} transaction parameters
 * @throws {Error} Throws an error if account index isn't valid
 */


exports.forceExit = forceExit;

var withdraw = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(amount, accountIndex, token, babyJubJub, batchNumber, merkleSiblings) {
    var isInstant,
        providerUrl,
        signerData,
        gasLimit,
        gasMultiplier,
        account,
        ethereumAddress,
        txSignerData,
        hermezContract,
        overrides,
        transactionParameters,
        _args3 = arguments;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            isInstant = _args3.length > 6 && _args3[6] !== undefined ? _args3[6] : true;
            providerUrl = _args3.length > 7 ? _args3[7] : undefined;
            signerData = _args3.length > 8 ? _args3[8] : undefined;
            gasLimit = _args3.length > 9 && _args3[9] !== undefined ? _args3[9] : _constants.GAS_LIMIT;
            gasMultiplier = _args3.length > 10 && _args3[10] !== undefined ? _args3[10] : _constants.GAS_MULTIPLIER;
            _context3.next = 7;
            return (0, _api.getAccount)(accountIndex).catch(function () {
              throw new Error('Invalid account index');
            });

          case 7:
            account = _context3.sent;
            ethereumAddress = (0, _addresses.getEthereumAddress)(account.hezEthereumAddress);
            txSignerData = signerData || {
              type: _signers.SignerType.JSON_RPC,
              addressOrIndex: ethereumAddress
            };
            hermezContract = (0, _contracts.getContract)(_constants.contractAddresses.Hermez, _HermezABI.default, providerUrl, txSignerData);
            _context3.t0 = gasLimit;
            _context3.next = 14;
            return getGasPrice(gasMultiplier, providerUrl);

          case 14:
            _context3.t1 = _context3.sent;
            overrides = {
              gasLimit: _context3.t0,
              gasPrice: _context3.t1
            };
            transactionParameters = [token.id, amount, "0x".concat(babyJubJub), batchNumber, merkleSiblings, (0, _addresses.getAccountIndex)(accountIndex), isInstant];
            return _context3.abrupt("return", hermezContract.withdrawMerkleProof.apply(hermezContract, transactionParameters.concat([overrides])).then(function () {
              return transactionParameters;
            }));

          case 18:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function withdraw(_x14, _x15, _x16, _x17, _x18, _x19) {
    return _ref3.apply(this, arguments);
  };
}();
/**
 * Makes the final withdrawal from the WithdrawalDelayer smart contract after enough time has passed.
 *
 * @param {String} hezEthereumAddress - The Hermez address of the transaction sender
 * @param {Object} token - The token information object as returned from the API
 * @param {String} providerUrl - Network url (i.e, http://localhost:8545). Optional
 * @param {Object} signerData - Signer data used to build a Signer to send the transaction
 * @param {Number} gasLimit - Optional gas limit
 * @param {Number} gasMultiplier - Optional gas multiplier
 * @returns {Promise} transaction parameters
 */


exports.withdraw = withdraw;

var delayedWithdraw = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(hezEthereumAddress, token, providerUrl, signerData) {
    var gasLimit,
        gasMultiplier,
        ethereumAddress,
        txSignerData,
        delayedWithdrawalContract,
        overrides,
        transactionParameters,
        _args4 = arguments;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            gasLimit = _args4.length > 4 && _args4[4] !== undefined ? _args4[4] : _constants.GAS_LIMIT;
            gasMultiplier = _args4.length > 5 && _args4[5] !== undefined ? _args4[5] : _constants.GAS_MULTIPLIER;
            ethereumAddress = (0, _addresses.getEthereumAddress)(hezEthereumAddress);
            txSignerData = signerData || {
              type: _signers.SignerType.JSON_RPC,
              addressOrIndex: ethereumAddress
            };
            delayedWithdrawalContract = (0, _contracts.getContract)(_constants.contractAddresses.WithdrawalDelayer, _WithdrawalDelayerABI.default, providerUrl, txSignerData);
            _context4.t0 = gasLimit;
            _context4.next = 8;
            return getGasPrice(gasMultiplier, providerUrl);

          case 8:
            _context4.t1 = _context4.sent;
            overrides = {
              gasLimit: _context4.t0,
              gasPrice: _context4.t1
            };
            transactionParameters = [ethereumAddress, token.id === 0 ? 0x0 : token.ethereumAddress];
            return _context4.abrupt("return", delayedWithdrawalContract.withdrawal.apply(delayedWithdrawalContract, transactionParameters.concat([overrides])).then(function () {
              return transactionParameters;
            }));

          case 12:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function delayedWithdraw(_x20, _x21, _x22, _x23) {
    return _ref4.apply(this, arguments);
  };
}();
/**
 * Sends a L2 transaction to the Coordinator
 * @param {Object} transaction - Transaction object prepared by TxUtils.generateL2Transaction
 * @param {String} bJJ - The compressed BabyJubJub in hexadecimal format of the transaction sender.
 * @return {Object} - Object with the response status, transaction id and the transaction nonce
*/


exports.delayedWithdraw = delayedWithdraw;

function sendL2Transaction(_x24, _x25) {
  return _sendL2Transaction.apply(this, arguments);
}
/**
 * Compact L2 transaction generated and sent to a Coordinator.
 * @param {Object} transaction - ethAddress and babyPubKey together
 * @param {String} transaction.from - The account index that's sending the transaction e.g hez:DAI:4444
 * @param {String} transaction.to - The account index of the receiver e.g hez:DAI:2156. If it's an Exit, set to a falseable value
 * @param {BigInt} transaction.amount - The amount being sent as a BigInt
 * @param {Number} transaction.fee - The amount of tokens to be sent as a fee to the Coordinator
 * @param {Number} transaction.nonce - The current nonce of the sender's token account
 * @param {Object} wallet - Transaction sender Hermez Wallet
 * @param {Object} token - The token information object as returned from the Coordinator.
*/


function _sendL2Transaction() {
  _sendL2Transaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(transaction, bJJ) {
    var result;
    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return (0, _api.postPoolTransaction)(transaction);

          case 2:
            result = _context6.sent;

            if (result.status === 200) {
              (0, _txPool.addPoolTransaction)(transaction, bJJ);
            }

            return _context6.abrupt("return", {
              status: result.status,
              id: result.data,
              nonce: transaction.nonce
            });

          case 5:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _sendL2Transaction.apply(this, arguments);
}

function generateAndSendL2Tx(_x26, _x27, _x28) {
  return _generateAndSendL2Tx.apply(this, arguments);
}

function _generateAndSendL2Tx() {
  _generateAndSendL2Tx = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(tx, wallet, token) {
    var l2TxParams, l2TxResult;
    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return (0, _txUtils.generateL2Transaction)(tx, wallet.publicKeyCompressedHex, token);

          case 2:
            l2TxParams = _context7.sent;
            wallet.signTransaction(l2TxParams.transaction, l2TxParams.encodedTransaction);
            _context7.next = 6;
            return sendL2Transaction(l2TxParams.transaction, wallet.publicKeyCompressedHex);

          case 6:
            l2TxResult = _context7.sent;
            return _context7.abrupt("return", l2TxResult);

          case 8:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _generateAndSendL2Tx.apply(this, arguments);
}